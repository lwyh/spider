"""

一个歌手准备从A城去B城参加演出。
1)按照合同，他必须在T天内赶到。
3)歌手不能往回走。
4)每两座城市之间需要的天数都可以提前获知。
5)歌手在每座城市都可以在路边卖唱赚钱。

经过调研，歌手提前获知了每座城市卖唱的收入预期：

如果在一座城市第一天卖唱可以赚M，后续每天的收入会减少D（第二天赚的钱是M-D，第三天是M-2D…）。

如果收入减到0就不会再少了。
6)歌手到达后的第二天才能开始卖唱。如果今天卖过唱，第二天才能出发。
贪心的歌手最多可以赚多少钱?
"""
import heapq
t,n= map(int,input().split())
#在每座城市待的天数
roadCoat = sum(map(int,input().split()))
#歌手在每座城市赚的钱
mds = [list(map(int,input().split())) for _ in range(n)]

#算法入门
def getRseult():
    #remain是刨去必要的路程时间，剩余可以用于赚钱的时间
    remain = t-roadCoat
    #如果没有剩余时间可以用，则赚不到钱
    if remain < 0:
        return 0
    
    #优先队列（小顶堆）记录转到的钱，即堆顶是某天赚到的最少的钱
    pq = []
    #第一天卖唱可以赚到的钱m,后续每天的收入会减少d
    for m,d in mds:
        #只要在当前城市还有钱赚，那么就继续坚持
        while m>0:  
            #只有remain天可以赚钱，超出的时间不能赚钱，因此需要比较超出的时间赚的钱，和前面时间中赚的最少的钱pq[0]
            if len(pq)>=remain:
                #pq[0]只可能是某座城市停留的最后一天的赚的钱，因为每座城市都是停留的最后一天赚的钱最少
                if m>pq[0]:
                #如果当前城市赚的钱m，比前天里面赚的最少的pq[0]钱的那天时间节约下来，给当天用
                    heapq.heappop(pq)
                else:
                #如果当前城市当天赚的钱m,比前天里面的赚的最少的pq[0]还少，则当前城市待下去的钱指挥更少，因此没必要呆下去了
                    break

            #如果当前城市还有钱赚,如果所有的城市停留时间没有超出remain天，或者当天是超出的时间，但是比前面赚的最少的一天的赚的更多，则赚m更优
            heapq.heappush(pq,m)
            print(pq)
            #每天收入减少d
            m-=d

    return sum(pq)
    
print(getRseult())

